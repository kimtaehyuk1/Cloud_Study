### 클라우드 서비스 가속 데이터 플레인

리뷰)
지금 리뷰듣고 생각되는것은 쿠버네티스에서 파드 투 파드는 통신은 지원되지 않아서 네트워크 플러그인을 써야됫지만 어제 배운 파드에서파드로 가는 내부의 cluster ip같은 경우는
네트워크 플러그인을 쓴느 파드 통신은 다른 파드를 의미하는것같고 내부 통신은 애초에 배포를 deployment로 scale out으로 해버리면 같은게 복제본느낌이니까 그때의 통신을 말하는것 같다.

또 scale up은 파드가 리소스 더 많이 사용할수 있게끔 리소스에대해 limit이나 request를 설정할수 있는데, 그런 값을 늘려주는것이고 scale out은 파드 복제해서 하나의 인스턴스가 서비스하기
보다는 복제해서 초당 request처리율을 높이는 방식이다.

## Ingress
service라는 객체자체가 L4스위치인데 예를들어 프론트엔드 서비스 유형들이 여러개가 잇다면 그 각각의 L4스위치 서비스 객체를 만들어주어야 하는데, 그러면 외부에서 접근하는 
접점이 많아지면 보안에 취약해진다 그래서 Ingress라는 L7스위치를 가지고 그러한 접점을 통합관리를 할 수 있다.

![인그레스](https://user-images.githubusercontent.com/67897827/155321843-1d81811e-68dc-4adf-bf0a-f2617122f0e0.PNG)

인그레스가 구성된 상태고 내부에 여러 서비스( 사진처럼 물론 노드는 3개여서 어느 서비스든 3개로 갈리지만 저렇게 떨어진 서비스3개는 종류가 다른 파드들인셈인거지... )
기반으로 배포된 시스템(파드)들이 있다. 서로다른 도메인으로 요청을해도 인그레스가 알아서 맞는 서비스의 파드로 포워딩 시켜준다.
-> simple fanout 과 virtual hosting방식으로 통합관리

또 애플리케이션 계층 스위치다 보니까 http 헤더를 볼 수 있다. 즉 클라이언트가 어떤 url로 요청했는지 파악할수 있는것이다.

/밑에는 영상속 내용을 필기한것이라 영상보면서 이해하기/ 또 다는 이해가 안되서 계속 들어보기 /
ingress_rbac.yaml명세서를 보며 kind에 ClusterRole이라고 되있는데 이거는(대쉬보에 왼쪽 보면 크게 클러스터와 네임스페이스라는 두가지 종류의 리소스로 나뉜다 그때의 클러스터임)
rule 이라는것은 apiGroups에 적혀있는 그룹에 리소스를 각각 verbs에 기능을 할 수있는 권한을 주는것이다. 이것을 클러스터롤로 정의한것이다. 그것을 ClusterRoleBinging을 통해 주체한테
assign을 해주는것이다. 이 ClusterRoleBinging 여기서 속성으로는 어떠한 주제한테 assign을 할지와 role에 대한 속성을 갖는다
(프로세스로 접근할때 그것을 식별할수 있는 주체가가 필요한데 그것을 ServiceAccount로 쿠버네티스에서 하고있다.) 또 그후에 ingress리소스가 rule set관리하는 리소스다.
/ 이하 생략 명세서보고 이해해보기...

## MSA
모놀리식와 어떤 차이가 있냐면 기존 모놀리식 앱은 하나의 프로그램안에 여러가지 기능들을 정의를 하고있다. 그들끼리는 펑션콜로 서로 밀접하게 연결되어 있다. 그말은
머 하나 고칠라하거나 업데이트하면 다른 연결되어있는 고리까지 다 건들여야되고, 내부 구조 복잡해진다 그러면 성능저하 이 문제 해결하려면 확장을 해야되는데 Scale up으로 (MSA의
확장 방식이 scale out인거에 비해서) **중요한내용으로 Scale out은 다른 노드로서 복제를 해서 계속 뻗어가지만 up방식은 하나의 노드에서 늘리는것이기 때문에 물리적으로 시스
템 사양에 한계가 있다** 또 MSA는 하나의 트래픽이 몰려도 다른놈한테는 영향을 주지 않는다.

개발자의 패키징과 운영팀에서의 배포의 환경이 맞지 않는 소통의 문제
이러한 어플리케이션들은 하나의 노드에 배포가 되는 구조이다. 이걸 MSA로 리펙토링한다면 각각의 펑션들로 구성되어있는 기능을 독립적인 서비스로 분리하는것이다. 
그러면 각각 시스템을 각각의 노드에 분리가 되어서 배포가 되어질수있다. 여기서는 펑션콜이아닌 네트워킹이 필요하다. 
즉 핵심기능 1가지만을 갖는 서비스로 분리시켜 개발하는것이다. 이것이 장점이고 이 1가지만 개발하는 독립적인 팀을 소규모로 꾸려서 개발가능 개발전략이나 언어 이런것들을 다 독립적으로 개발 할 수있고, 또 그 기능과 가장 적합한 저장소를 선택해 유지 관리할수도 있다.


![MSA](https://user-images.githubusercontent.com/67897827/155477037-3b79ad5d-9216-4a4e-b662-b3776b645811.PNG)

이러한 MSA로 디자인을 했을때는 보통 REST API를 제공하는 형태로 개발하는데, 이렇게 하게되면 다양한 언어로 클라이언트 앱을 개발 할 수 있게 된다. 이 REST API또한 하나로 통합관리가
필요해서 보통은 API GATEWAY서비스를 통해 트래픽을 라우팅하게 구현가능 

쿠버네티스에서는 auto scaling도 제공함

## Security
1. API Server 보안
api server는 실제로 파드 형태로 배포가 되는데 이 파드안에 프로세서가 동작한다. 이 프로세스 내에서는 어떤 기능을 담당하느냐?
바로 인증. **인증만 담당이아닌 인증된 사용자에 대해 권한을 준다. 이 권한을 RBAC으로 적용해서 쓰고 있다( role기반에 access controll 방식)** 그후 Admission control plugin을 
통과해야 한다. 일반적인 파드 명세서에 요청 limit에대한 리소스 요청을 하지 않더라도 기본으로 이놈에서 세팅이된다.

**여기서 파드내의 프로세스가 리소스의 접근 권한이 있는지 없는지를 check를 해야되고, 그 주체를 식별하는 단위로 Service Account 사용한다.**

**즉 권한을 RBAC으로 주어야지 Service Account를 이용해서 리소스에 접근이 가능하다. 쉽게 말해 알백과 서비스 어카운트는 열쇠와 잠물쇠 같은 느낌 둘이 맞아야
리소스 접근 가능하다.**

## RBAC
핵심요소로 주체가 있고 액션이 있다. 사용자나 그룹이라는 주체에 role을 부여하는 방식으로 접근제어를 한다. role은 사용자가 어떠한 액션을 할 수있는지 리소스와 함께 명시
즉 알백의 핵심은 role과 rolebinding이다. 여기서 role자체는 ns 리소스에 대한 role이냐, 클러스터 리소스에 대한 role이냐 2가지가 있고 그것에 따라 바인딩도 두가지 


## 인증
- Kubectl 명령어로 api서버로 요청이 가는데 지금 이 사용자가 커맨드 요청할떄 인증서 기반으로 요청을 하는데, 그 인증서가 합법적으로 권한이 있는지 인증해야된다
토큰기반,클라이언트 인증서,Http인증서 등으로 인증을 하게된다.

인증을 할때 주체가 있을텐데, 사용자 또는 그룹이 있다. 여기서 사용자는 실제 사람이 될 수 도있고, 파드내 app이 될수도 있다. 사람이 접근하면 쿠버네티스 자체는
인증 시스템이 없어서 외부시스텀과 연동하는 방식이고, 파드내 app이 접근을 하면 Service Account를 연결해서 사용한다. 
실제사람은 리소스로 관리 안된다.(즉 kubectl get user이거 안된다) 하지만 Service Account는 리소스로 관리되어서 list로 볼 수 있다.


## Service Mesh

![서비스 매쉬](https://user-images.githubusercontent.com/67897827/155555748-0c2a1bcf-1a3b-40cb-9f0c-5646719a89ca.PNG)
MSA는 모놀리식 단점을 극복하는 좋은 장점을 가지고 있으나 컴포넌트수가 많아진다는 단점이 있었다. 컴포넌트수가 많아짐에 따라 또 그것을 관리해야하는 문제가 생긴다.
또 이런 컴포넌트들이 멀티노드에 분산되어 어떤 비지니스 로직을 처리한다 했을떄 장애가 발생했을떄의 트레킹작업이 쉽지 않다. 이것을 극복하기위해 나온것이 Service Mesh이다.
즉 별도의 네트워킹이라는 기능으로 별도로 추가해서 쓰는 방식이다. 기존의 어플리케이션 자체의 코드를 수정할 필요가 없다.외부 사이드카로 주입하여 

