1. 모놀리식 아키텍처
서비스를 만들때 큰덩어리로 그것을 모두 묶어서 하나로 관리하는것

장점
* End-to-End 테스트가 용이
* 빠르게 간단한 서비스를 만들 수 있음
단점
* 조그마한 수정사항이 있어도 전체를 다시 빌드하고 배포
* 유지보수도 힘듬
* 덩치가 너무 커져 구동시간이 늘어남
* 일부분의 오류가 전체에 영향을 미침
* 각 기능에 따라 다른 언어를 선택할 수 없음

2. 마이크로서비스 아키텍처
서비스의 다양한 기능들을 잘게 쪼개서 관리

장점
* 유지보수 용이
* 거대한 서비스도 빠르게 수정 가능
* 각 기능에 따라 다른 언어를 선택할 수 있음
단점
* 모니터링이 힘듬
* End-to-end 서비스 구동 불편(테스트가 불편)


★★★Django를 통해 빽엔드 작업했던 온라인주문서비스 프로젝트를 인프라 연결★★★(인프라 부분에만 초점)
1. 가장 먼저 AWS RDS 데이터베이스 생성(mySQL로,프리티어,마스터암호설정,퍼블릭 액세스 가능하게,추가구성가서 초기데이터베이스이름설정
2. 잔고 가서 mysql다운, 잔고 세팅에가서 몇가지 RDS에서 정해준거 추가하기 이쪽으로 migrate하기

* EC2에 배포하기가 있는데 이것은 이해잘 안됨.

※ 로드밸런싱
서버(한대) 용량을 올리면 비용측면에서 기하급수적으로 늘어남 즉 같은 용량의 서버를 여러대 늘려서 구동시키는데
그 가운데에서 Load Balancer(ELB)라는 놈이 알아서 여러 서버에 교통정리를 해줌
- 종류가 2가지가 있는데 처음으로 L4로드밸런싱이라고 옛날에 쓰던거 AWS에선 클래식로드밸런싱인 CLB로 부른다
L4 로드밸런서는 단순하게 IP주소와 포트만 본다(즉 트래픽이 어디서 왔는지 위치만 본다) 데이터를 안본다 그래서 빠르다
단점으로는 마이크로서비스에선 불리하다(즉 /order라는 것이 있으면 그거에 맞는 서버에 보낸다는건데 L4이놈은 데이터 안보니까 그런거모름)
L7은 데이터까지 뜯어서 이건 저기 보내야겠네를 앎으로 스마트하고 마이크로서비스에 유리하며 비용이나 속도는 느리다. AWS에선 Application LB인 ALB라함

※ L7 로드밸런싱 실습
EC2와 로드밸런싱과 연결해야되기 위해 먼저 대상그룹 만들어야함 걍 EC2서버의 집합체라고 생각하면된다. 나중에 마이크로서비스에서 이런 집합들을 다르게 만들어서
집합안에 서버들을 만드는 이런 느낌
대상그룹만들기
-> 인스턴스 체크,이름아무거나,포트는 8000(이건 로드밸런서로 부터 트래픽올때 어느 포트로 보내줄거냐 우리는 8000포트로 지정해놔서)
health check는 대상그룹안에 특정서버 다운되면 그거 대비해 로드밸런서가 헬쓰체크함 path는 url로(여긴 잘모름 잔고안해서)
그 후에 대상그룹과 로드밸런서를 연결한다(로드밸런서 생성 누름) -> ALB선택, 리스너칸에는 우린 8000포트로 전달해야되기 때문에 HTTP 8000이라고 하고
보안그룹도 8000허용, 대상그룹은 만들었으니까 걍 넘기기

음.. 자세히는 로드밸런싱한테가는건 유저가 80포트 열어주고 대상그룹안에 EC2는 8000으로 지정했으니까 8000포트 열어주고

로드밸런싱 되는거 보기위해 인스턴스에서 오른쪽 마우스 이미지 및 템플릿에서 이미지 생성해서 그 속성값 그대로 저장해놓는다 그러면 이미지 칸에 행생기면
시작하기해서 이미지에 해당하는 EC2만들기 -> 그 후 대상그룹을 하나 새로 만들고  대상그룹등록하기해서 만든 EC2추가 -> 로드밸런서 가서 리스너에 tg규칙보기 편집을
누르고 규칙 추가해서 경로 /delivery로 시작하면 이건 tg2로전달해라 이거 올려주면 나머지는 다 tg1으로 간다.


![image](https://user-images.githubusercontent.com/67897827/180229362-43e1532b-d045-4343-aa17-a1281506a14e.png)
대상그룹 다르게 설정해서 그룹안에 서버들있게 L7은 url로 구분해 이렇게 똑똑하게 나눠준다.
또 Sticky Session이라는 개념이있는데, 이건 유저가 로드밸런싱 타고 EC2들어왔을때,세션값을 저장하게 됬다가(예를들어 로그인 다시 안하고 바로 할 수 있게끔) 근데 새로고침누르면
자꾸 다른 EC2로 가버리니까 차라리 로드밸런싱단에서 세션값을 가지고있다가 최초 저장해논 EC2로 가게 해주는 개념이다.

※ Route53 공부
![image](https://user-images.githubusercontent.com/67897827/180236755-59def610-ff54-4829-9159-3bbf848a40ee.png)
1. 도메인 등록 절차
(도메인과 특정 ip주소와 링크시켜 등록시켜한다.)최종적으로 등록소에 등록하기위해 대행소가 있다(대신 등록해주는것이다.)
freenom이나 AWS Route53이 등록대행자 역활을 한다. 등록하게되면 등록대행자에 DNS server(어떤 url과 어떤 ip주소가 링크되어있다는 정보가 저장)가 자동으로 생기게 된다.
그러면 등록대행자가 DNS server을 등록을 한다 = 등록소의 Top level domain에 등록을 한다
2. 클라이언트 상에서의 절차
등록후 클라이언트가 url을 친다-> 클라이언트는 ICANN에 Root name server에 물어본다. 그후 ICANN은 요청을 .com(예를들면)등록소에 보내준다 -> 등록소내에서 찾는다. 후에 응답함

여기서 AWS Route53은 등록대행을 해주는 역할과 DNS server(어떤 url과 어떤 ip주소가 링크되어있다는 정보가 저장)을 만들어주는 역할을 한다 크게 2가지. 또한 Route53을 쓰는이유는 
AWS의 다양한 서비스와 같이 쓰려면 이걸 써야됨

※ Route53 실습
Route53입력해서 카테고리의 등록된 도메인 눌러보기-> 도메인 등록(그 도메인을 사는거임)->정보입력
그후에는 우리가 Route53만든 도메인을 ELB에 등록시켜줘야된다. 그러면 유저가 그 등록 도메인에 접속 했을때 마치 ELB에 접속하는것과 같은것이다.
그 후 구매한 도메인에대한 호스팅영역역을 설정해야된다. 어떠한작업도 하지않고 도메인 클릭해서 들어가보면 2개행이 떠있는데 NS,SOA유형이 떠있다. 이건 AWS로 했기때문에
이게 자동으로 있는것이다. 또 레코드 추가 눌러서 유형을 A로 하고 값을 별칭눌러서 ELB 선택해서(이게 ELB에 등록하는거다)

※ https 실습
![image](https://user-images.githubusercontent.com/67897827/180254482-15199360-0d32-43f4-bfa8-b27214e786fb.png)
ELB에서 443 https포트 연다해도 인증서가 없으면 막힌다. 즉 인증서를 만들어서 Route53에 연결해줘야함
AWS certificate Manager들어가기 인증서 프로비저닝 시작->공인인증서 요청->도메인이름 쓰기(https적용할)->검증방법이나오는데(도메인추가했던 그 도메인이 내꺼다를 증명하는
방법이다) DNS검증 -> 태그는 맘대로 -> 검증함
자! DNS검증을 어떻게 하냐면 마지막 검증단계에서 보여지는 이름 유형(CNAME) 값이 Route53값에 추가된다.(레코드 생성 눌러주기)
그러면 인증서 발급받을때 받은 CNAME유형과 실제 호스팅영역에 있는 레코드와 같은지 검증 !!!여기까지가 인증서 등록한거다 근데 여기서 끝이아니라
로드밸런서 가서 https인 443포트도 열어주자(리스너추가) 기본작업에 전달대상 대상그룹추가하고 SSL인증서도 있는데 이건 아까 certification 인증서이다.

※ AWS CloudFront와 CDN의 공부
-Cloudfront = Cache + CDN(캐쉬서버니까 당연하게 CDN도있네)
-기본적으로는 Cache 서버
-Cache 서버는 전 세계에 흩어져 있는 인프라를 활용하기 때문에 추가적으로 CDN의 기능도 보유
-웹 서버의 비용을 감소시키며, 전 세계의 유저를 대상으로 고속으로 웹서비스를 제공하도록 하는 서비스

쉽게말해 내가 서울에 EC2를 만들면 싱가폴에서 이걸 쓰는 사람은 느리기 마련인데, 그렇지 않고 Cloudfront를 사용하면 어디에있는 고속으로 사용하는거
CDN개념도 이개념이다. 전세계 어느 위치에서 접속하더라도 빠른 속도로 서비스할 수 있도록 하는 서비스이다.
결국 처음엔 느릴수있어도 이거 불러오면 가까이에있는 엣지로케이션에 있는 캐쉬서버에 저장을 시키는 것이다.

기존에 캐쉬없을땐 유저가 요청하면 준비해놨다가 뿌려주는것이 아니라, 동적으로 생성하는 방식으로 느리고 서버입장에선 서버비용이 많이 나간다. 유저가 새로고침하면
서버는 똑같은 작업을 계속해야하기 때문에 너무 비효율적이다. 캐쉬가 생기고 최초만 서버만 계산하고 똑같은 연산을 해야될때는 결과를 캐쉬서버를 저장해놓기때문에
또 할 필요가 없다.

하지만 문제는 캐쉬서버를 이용하면, 유저가 만약 정보가 바뀌면 월래 오리진을 거치면 다시 계산해서 새롭게 알려주면되는데 캐쉬서버는 바뀌기전꺼 저장해놓기에
잘못된 결과를 뿌려준다. 그래서 캐쉬서버를 갈아엎는 텀을둬서 주기간격으로 캐쉬서버를 새로고침한다. 그래서 캐쉬서버를 이용할때는 잘 바뀌지않는 개인정보같은것만 주로 사용하면
새로고침 주기를 늘려도되니까 이때 효율적이다.


![image](https://user-images.githubusercontent.com/67897827/180271301-db7b267e-0f54-4a4e-826a-e47f492c16ea.png)
즉 그림을 설명하면
유저가 https로 접속하면 인증서받아서 Route53을 Cloudfront에 등록을 시키고 이제 그 Cloudfront가 ALB에 등록이 되는것이다.

※ AWS CloudFront 실습
cloudfront쳐서 distribution만들기 누름(캐쉬서버같은거다)->origin이름은 ELB로 잡기,path무시,Distribution 세팅에서 Price Class를 use all로하면 전세계있는 모든 엣지로케이션을
캐쉬서버로 사용한다 주고객이 영어쓰는 사람들이면 only U.S로 해도된다.-> CNAME적는 칸에 Route53에서 만든 도메인 넣주기-> 또 https로 연결할거기 때문에 SSL Certificate
에 Custom SSL 눌러서 인증서 연결->만들기누르기
그 다음에 Route53에 들어가서 유형A되있는걸 이제 Cloudfront에 연결되있어야 한다.레코드 편집들어가서 별칭에서 LB가 아닌 CF로 바꿔주고 배포선택에서 CloudFront Distribution
에서 만든거 누르기 이렇게 까지 하면 Cloudfront이용해서 접근하고 있는거다.
또 그후에는 만들어진 Cloudfront들어가서 Behaviors에가서 기존 Behaviors edit하면 Legacy cache settings 밑에 Customize밑에 TTL이란게 있는데, 이건 오리진에서 엣지 로켓이션
까지 반영되는 시간이다.(초단위)




